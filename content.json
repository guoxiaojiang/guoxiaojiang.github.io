{"meta":{"title":"郭效江","subtitle":"初学者","description":"stay hungry stay foolish","author":"郭效江","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-05-04T09:35:52.000Z","updated":"2017-05-04T09:32:06.000Z","comments":true,"path":"tech/ArrayList遍历删除相关.html","permalink":"http://yoursite.com/tech/ArrayList遍历删除相关.html","excerpt":"","text":"#Java ArrayList遍历删除相关以前面试被问过java.util.ArrayList遍历删除相关的问题。后来的工作中也遇到了一些坑，今天拿出来总结一下。如下： 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"str1\"); list.add(\"str2\"); list.add(\"str2\"); list.add(\"str3\"); list.add(\"str3\"); list.add(\"str3\"); //删除所有\"str2\"元素 doRemoveStr2(list); System.out.println(list);&#125; ##方法一：12345678public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); if (str.equals(\"str2\")) &#123; list.remove(str); &#125; &#125; &#125; 结果：第二个”str2”没有被删掉。 ###错误原因首先看下ArrayList源码： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; fastRemove： 1234567private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index,numMoved); elementData[--size] = null; // Let gc do its work &#125; 可以看到，在遍历到第一个”str2”时，符合删除条件，/Users/guoxiaojiang/tech_docs/hexo/source/_posts/ArrayList遍历删除相关.md把它从数组中删除，并且把后一个元素，也就是第二个”str2”移动到当前位置，这样，下次循环遍历时就会跳过它，所以无法删除。 ###解决方法倒序遍历删除： 12345678public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (int i = list.size() - 1; i &gt;= 0; i--) &#123; String s = list.get(i); if (s.equals(\"str2\")) &#123; list.remove(s); &#125; &#125; &#125; ###注有时为了优化，在遍历之前先把list.size()计算出来保存起来，在这种情况下，list.size()是没有删除之前的大小，最终会报ArrayIndexOutOfBoundsException，注意此坑。 ##方法二：使用for-each遍历删除 1234567public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (String s : list) &#123; if (s.equals(\"str2\")) &#123; list.remove(s); &#125; &#125; &#125; ###结果报出异常：Java.util.ConcurrentModificationException ###错误原因foreach写法实际是对Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法： 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125; 第一行checkForComodification方法： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。 ##正确方法使用迭代器迭代，（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。 123456789public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String s = it.next(); if (s.equals(\"str2\")) &#123; it.remove(); &#125; &#125; &#125; ##One more thing如果把之前的list元素改为如下： 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"str1\"); list.add(\"str2\"); list.add(\"str3\"); for (String s : list) &#123; if (\"str2\".equals(s)) &#123; list.remove(s); &#125; &#125; System.out.println(list);&#125; 各位一定会觉得此时还会抛著名的ConcurrentModificationException吧？可实际的结果是，正确的输出了[str1,str3]。 这就还需要看一下AbstractList内部类Itr中的hasNext 123public boolean hasNext() &#123; return cursor != size();&#125; 当元素”str2”被删除后，cursor的值正好与数组的size()相等，所以Itr的遍历任务已经结束，不再会去获取下一个元素，所以也就没有抛异常了。当然这个情况只有在删除数组中的倒数第二个元素时才会出现，只是一个巧合现象，在开发中，我们还是绝对禁止在遍历list的时候直接使用list.remove()方法来删除元素的。"}],"posts":[{"title":"来碗米国浓鸡汤","slug":"来碗米国浓鸡汤","date":"2017-05-04T10:20:21.000Z","updated":"2017-05-04T10:28:21.000Z","comments":true,"path":"2017/05/04/来碗米国浓鸡汤/","link":"","permalink":"http://yoursite.com/2017/05/04/来碗米国浓鸡汤/","excerpt":"","text":"来碗米国浓鸡汤 New York is 3 hours ahead of California, but it does not make California slow. Someone graduated at the age of 22, but waited 5 years before securing a good job! Someone became a CEO at 25, and died at 50. While another became a CEO at 50, and lived to 90 years. Someone is still single, while someone else got married. Obama retires at 55, but Trump starts at 70. Absolutely everyone in this world works based on their Time Zone. People around you might seem to go ahead of you, some might seem to be behind you. But everyone is running their own RACE, in their own TIME. Don’t envy them or mock them. They are in their TIME ZONE, and you are in yours! Life is about waiting for the right moment to act. So, RELAX. You’re not LATE. You’re not EARLY. You are very much ON TIME, and in your TIME ZONE.","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]},{"title":"Java ArrayList遍历删除相关","slug":"ArrayList遍历删除相关","date":"2017-05-04T07:30:00.000Z","updated":"2017-05-04T10:30:35.000Z","comments":true,"path":"2017/05/04/ArrayList遍历删除相关/","link":"","permalink":"http://yoursite.com/2017/05/04/ArrayList遍历删除相关/","excerpt":"","text":"Java ArrayList遍历删除相关 以前面试被问过java.util.ArrayList遍历删除相关的问题。后来的工作中也遇到了一些坑，今天拿出来总结一下。如下： 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"str1\"); list.add(\"str2\"); list.add(\"str2\"); list.add(\"str3\"); list.add(\"str3\"); list.add(\"str3\"); //删除所有\"str2\"元素 doRemoveStr2(list); System.out.println(list);&#125; 方法一：12345678public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; String str = list.get(i); if (str.equals(\"str2\")) &#123; list.remove(str); &#125; &#125; &#125; 结果：第二个”str2”没有被删掉。 错误原因首先看下ArrayList源码： 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; fastRemove： 1234567private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index,numMoved); elementData[--size] = null; // Let gc do its work &#125; 可以看到，在遍历到第一个”str2”时，符合删除条件，/Users/guoxiaojiang/tech_docs/hexo/source/_posts/ArrayList遍历删除相关.md把它从数组中删除，并且把后一个元素，也就是第二个”str2”移动到当前位置，这样，下次循环遍历时就会跳过它，所以无法删除。 解决方法倒序遍历删除： 12345678public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (int i = list.size() - 1; i &gt;= 0; i--) &#123; String s = list.get(i); if (s.equals(\"str2\")) &#123; list.remove(s); &#125; &#125; &#125; 注有时为了优化，在遍历之前先把list.size()计算出来保存起来，在这种情况下，list.size()是没有删除之前的大小，最终会报ArrayIndexOutOfBoundsException，注意此坑。 方法二：使用for-each遍历删除 1234567public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; for (String s : list) &#123; if (s.equals(\"str2\")) &#123; list.remove(s); &#125; &#125; &#125; 结果报出异常：Java.util.ConcurrentModificationException 错误原因foreach写法实际是对Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法： 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125; 第一行checkForComodification方法： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。 正确方法使用迭代器迭代，（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。 123456789public static void doRemoveStr2(ArrayList&lt;String&gt; list) &#123; Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String s = it.next(); if (s.equals(\"str2\")) &#123; it.remove(); &#125; &#125; &#125; One more thing如果把之前的list元素改为如下： 123456789101112public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"str1\"); list.add(\"str2\"); list.add(\"str3\"); for (String s : list) &#123; if (\"str2\".equals(s)) &#123; list.remove(s); &#125; &#125; System.out.println(list);&#125; 各位一定会觉得此时还会抛著名的ConcurrentModificationException吧？可实际的结果是，正确的输出了[str1,str3]。 这就还需要看一下AbstractList内部类Itr中的hasNext 123public boolean hasNext() &#123; return cursor != size();&#125; 当元素”str2”被删除后，cursor的值正好与数组的size()相等，所以Itr的遍历任务已经结束，不再会去获取下一个元素，所以也就没有抛异常了。当然这个情况只有在删除数组中的倒数第二个元素时才会出现，只是一个巧合现象，在开发中，我们还是绝对禁止在遍历list的时候直接使用list.remove()方法来删除元素的。","categories":[{"name":"tech","slug":"tech","permalink":"http://yoursite.com/categories/tech/"}],"tags":[]}]}